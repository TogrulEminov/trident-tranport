/*!
 * Bootstrap v5.3.0 (https://getbootstrap.com/)
 * Copyright 2011-2023 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */ !(function (t, e) {
  "object" == typeof exports && "undefined" != typeof module
    ? (module.exports = e(require("@popperjs/core")))
    : "function" == typeof define && define.amd
    ? define(["@popperjs/core"], e)
    : ((t =
        "undefined" != typeof globalThis ? globalThis : t || self).bootstrap =
        e(t.Popper));
})(this, function (t) {
  "use strict";
  let e = (function t(e) {
      let i = Object.create(null, {
        [Symbol.toStringTag]: { value: "Module" },
      });
      if (e) {
        for (let s in e)
          if ("default" !== s) {
            let n = Object.getOwnPropertyDescriptor(e, s);
            Object.defineProperty(
              i,
              s,
              n.get ? n : { enumerable: !0, get: () => e[s] }
            );
          }
      }
      return (i.default = e), Object.freeze(i);
    })(t),
    i = new Map(),
    s = {
      set(t, e, s) {
        i.has(t) || i.set(t, new Map());
        let n = i.get(t);
        n.has(e) || 0 === n.size
          ? n.set(e, s)
          : console.error(
              `Bootstrap doesn't allow more than one instance per element. Bound instance: ${
                Array.from(n.keys())[0]
              }.`
            );
      },
      get: (t, e) => (i.has(t) && i.get(t).get(e)) || null,
      remove(t, e) {
        if (!i.has(t)) return;
        let s = i.get(t);
        s.delete(e), 0 === s.size && i.delete(t);
      },
    },
    n = "transitionend",
    r = (t) => (
      t &&
        window.CSS &&
        window.CSS.escape &&
        (t = t.replace(/#([^\s"#']+)/g, (t, e) => `#${CSS.escape(e)}`)),
      t
    ),
    o = (t) => {
      t.dispatchEvent(new Event(n));
    },
    l = (t) =>
      !(!t || "object" != typeof t) &&
      (void 0 !== t.jquery && (t = t[0]), void 0 !== t.nodeType),
    a = (t) =>
      l(t)
        ? t.jquery
          ? t[0]
          : t
        : "string" == typeof t && t.length > 0
        ? document.querySelector(r(t))
        : null,
    h = (t) => {
      if (!l(t) || 0 === t.getClientRects().length) return !1;
      let e = "visible" === getComputedStyle(t).getPropertyValue("visibility"),
        i = t.closest("details:not([open])");
      if (!i) return e;
      if (i !== t) {
        let s = t.closest("summary");
        if ((s && s.parentNode !== i) || null === s) return !1;
      }
      return e;
    },
    c = (t) =>
      !t ||
      t.nodeType !== Node.ELEMENT_NODE ||
      !!t.classList.contains("disabled") ||
      (void 0 !== t.disabled
        ? t.disabled
        : t.hasAttribute("disabled") && "false" !== t.getAttribute("disabled")),
    d = (t) => {
      if (!document.documentElement.attachShadow) return null;
      if ("function" == typeof t.getRootNode) {
        let e = t.getRootNode();
        return e instanceof ShadowRoot ? e : null;
      }
      return t instanceof ShadowRoot
        ? t
        : t.parentNode
        ? d(t.parentNode)
        : null;
    },
    u = () => {},
    g = (t) => {
      t.offsetHeight;
    },
    f = () =>
      window.jQuery && !document.body.hasAttribute("data-bs-no-jquery")
        ? window.jQuery
        : null,
    p = [],
    m = () => "rtl" === document.documentElement.dir,
    b = (t) => {
      var e;
      (e = () => {
        let e = f();
        if (e) {
          let i = t.NAME,
            s = e.fn[i];
          (e.fn[i] = t.jQueryInterface),
            (e.fn[i].Constructor = t),
            (e.fn[i].noConflict = () => ((e.fn[i] = s), t.jQueryInterface));
        }
      }),
        "loading" === document.readyState
          ? (p.length ||
              document.addEventListener("DOMContentLoaded", () => {
                for (let t of p) t();
              }),
            p.push(e))
          : e();
    },
    v = (t, e = [], i = t) => ("function" == typeof t ? t(...e) : i),
    y = (t, e, i = !0) => {
      if (!i) return void v(t);
      let s =
          ((t) => {
            if (!t) return 0;
            let { transitionDuration: e, transitionDelay: i } =
                window.getComputedStyle(t),
              s = Number.parseFloat(e),
              n = Number.parseFloat(i);
            return s || n
              ? ((e = e.split(",")[0]),
                (i = i.split(",")[0]),
                1e3 * (Number.parseFloat(e) + Number.parseFloat(i)))
              : 0;
          })(e) + 5,
        r = !1,
        l = ({ target: i }) => {
          i === e && ((r = !0), e.removeEventListener(n, l), v(t));
        };
      e.addEventListener(n, l),
        setTimeout(() => {
          r || o(e);
        }, s);
    },
    w = (t, e, i, s) => {
      let n = t.length,
        r = t.indexOf(e);
      return -1 === r
        ? !i && s
          ? t[n - 1]
          : t[0]
        : ((r += i ? 1 : -1),
          s && (r = (r + n) % n),
          t[Math.max(0, Math.min(r, n - 1))]);
    },
    A = /[^.]*(?=\..*)\.|.*/,
    C = /\..*/,
    E = /::\d+$/,
    T = {},
    k = 1,
    L = { mouseenter: "mouseover", mouseleave: "mouseout" },
    $ = new Set([
      "click",
      "dblclick",
      "mouseup",
      "mousedown",
      "contextmenu",
      "mousewheel",
      "DOMMouseScroll",
      "mouseover",
      "mouseout",
      "mousemove",
      "selectstart",
      "selectend",
      "keydown",
      "keypress",
      "keyup",
      "orientationchange",
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel",
      "pointerdown",
      "pointermove",
      "pointerup",
      "pointerleave",
      "pointercancel",
      "gesturestart",
      "gesturechange",
      "gestureend",
      "focus",
      "blur",
      "change",
      "reset",
      "select",
      "submit",
      "focusin",
      "focusout",
      "load",
      "unload",
      "beforeunload",
      "resize",
      "move",
      "DOMContentLoaded",
      "readystatechange",
      "error",
      "abort",
      "scroll",
    ]);
  function S(t, e) {
    return (e && `${e}::${k++}`) || t.uidEvent || k++;
  }
  function I(t) {
    let e = S(t);
    return (t.uidEvent = e), (T[e] = T[e] || {}), T[e];
  }
  function D(t, e, i = null) {
    return Object.values(t).find(
      (t) => t.callable === e && t.delegationSelector === i
    );
  }
  function O(t, e, i) {
    let s = "string" == typeof e,
      n = _(t);
    return $.has(n) || (n = t), [s, s ? i : e || i, n];
  }
  function N(t, e, i, s, n) {
    var r, o, l, a, h, c;
    if ("string" != typeof e || !t) return;
    let [d, u, g] = O(e, i, s);
    e in L &&
      (u =
        ((r = u),
        function (t) {
          if (
            !t.relatedTarget ||
            (t.relatedTarget !== t.delegateTarget &&
              !t.delegateTarget.contains(t.relatedTarget))
          )
            return r.call(this, t);
        }));
    let f = I(t),
      p = f[g] || (f[g] = {}),
      m = D(p, u, d ? i : null);
    if (m) return void (m.oneOff = m.oneOff && n);
    let b = S(u, e.replace(A, "")),
      v = d
        ? ((o = t),
          (l = i),
          (a = u),
          function t(e) {
            let i = o.querySelectorAll(l);
            for (let { target: s } = e; s && s !== this; s = s.parentNode)
              for (let n of i)
                if (n === s)
                  return (
                    F(e, { delegateTarget: s }),
                    t.oneOff && M.off(o, e.type, l, a),
                    a.apply(s, [e])
                  );
          })
        : ((h = t),
          (c = u),
          function t(e) {
            return (
              F(e, { delegateTarget: h }),
              t.oneOff && M.off(h, e.type, c),
              c.apply(h, [e])
            );
          });
    (v.delegationSelector = d ? i : null),
      (v.callable = u),
      (v.oneOff = n),
      (v.uidEvent = b),
      (p[b] = v),
      t.addEventListener(g, v, d);
  }
  function P(t, e, i, s, n) {
    let r = D(e[i], s, n);
    r && (t.removeEventListener(i, r, Boolean(n)), delete e[i][r.uidEvent]);
  }
  function x(t, e, i, s) {
    let n = e[i] || {};
    for (let [r, o] of Object.entries(n))
      r.includes(s) && P(t, e, i, o.callable, o.delegationSelector);
  }
  function _(t) {
    return L[(t = t.replace(C, ""))] || t;
  }
  let M = {
    on(t, e, i, s) {
      N(t, e, i, s, !1);
    },
    one(t, e, i, s) {
      N(t, e, i, s, !0);
    },
    off(t, e, i, s) {
      if ("string" != typeof e || !t) return;
      let [n, r, o] = O(e, i, s),
        l = o !== e,
        a = I(t),
        h = a[o] || {},
        c = e.startsWith(".");
      if (void 0 === r) {
        if (c) for (let d of Object.keys(a)) x(t, a, d, e.slice(1));
        for (let [u, g] of Object.entries(h)) {
          let f = u.replace(E, "");
          (l && !e.includes(f)) || P(t, a, o, g.callable, g.delegationSelector);
        }
      } else {
        if (!Object.keys(h).length) return;
        P(t, a, o, r, n ? i : null);
      }
    },
    trigger(t, e, i) {
      if ("string" != typeof e || !t) return null;
      let s = f(),
        n = null,
        r = !0,
        o = !0,
        l = !1;
      e !== _(e) &&
        s &&
        ((n = s.Event(e, i)),
        s(t).trigger(n),
        (r = !n.isPropagationStopped()),
        (o = !n.isImmediatePropagationStopped()),
        (l = n.isDefaultPrevented()));
      let a = F(new Event(e, { bubbles: r, cancelable: !0 }), i);
      return (
        l && a.preventDefault(),
        o && t.dispatchEvent(a),
        a.defaultPrevented && n && n.preventDefault(),
        a
      );
    },
  };
  function F(t, e = {}) {
    for (let [i, s] of Object.entries(e))
      try {
        t[i] = s;
      } catch (n) {
        Object.defineProperty(t, i, { configurable: !0, get: () => s });
      }
    return t;
  }
  function j(t) {
    if ("true" === t) return !0;
    if ("false" === t) return !1;
    if (t === Number(t).toString()) return Number(t);
    if ("" === t || "null" === t) return null;
    if ("string" != typeof t) return t;
    try {
      return JSON.parse(decodeURIComponent(t));
    } catch (e) {
      return t;
    }
  }
  function z(t) {
    return t.replace(/[A-Z]/g, (t) => `-${t.toLowerCase()}`);
  }
  let H = {
    setDataAttribute(t, e, i) {
      t.setAttribute(`data-bs-${z(e)}`, i);
    },
    removeDataAttribute(t, e) {
      t.removeAttribute(`data-bs-${z(e)}`);
    },
    getDataAttributes(t) {
      if (!t) return {};
      let e = {},
        i = Object.keys(t.dataset).filter(
          (t) => t.startsWith("bs") && !t.startsWith("bsConfig")
        );
      for (let s of i) {
        let n = s.replace(/^bs/, "");
        e[(n = n.charAt(0).toLowerCase() + n.slice(1, n.length))] = j(
          t.dataset[s]
        );
      }
      return e;
    },
    getDataAttribute: (t, e) => j(t.getAttribute(`data-bs-${z(e)}`)),
  };
  class q {
    static get Default() {
      return {};
    }
    static get DefaultType() {
      return {};
    }
    static get NAME() {
      throw Error(
        'You have to implement the static method "NAME", for each component!'
      );
    }
    _getConfig(t) {
      return (
        (t = this._mergeConfigObj(t)),
        (t = this._configAfterMerge(t)),
        this._typeCheckConfig(t),
        t
      );
    }
    _configAfterMerge(t) {
      return t;
    }
    _mergeConfigObj(t, e) {
      let i = l(e) ? H.getDataAttribute(e, "config") : {};
      return {
        ...this.constructor.Default,
        ...("object" == typeof i ? i : {}),
        ...(l(e) ? H.getDataAttributes(e) : {}),
        ...("object" == typeof t ? t : {}),
      };
    }
    _typeCheckConfig(t, e = this.constructor.DefaultType) {
      var i;
      for (let [s, n] of Object.entries(e)) {
        let r = t[s],
          o = l(r)
            ? "element"
            : null == (i = r)
            ? `${i}`
            : Object.prototype.toString
                .call(i)
                .match(/\s([a-z]+)/i)[1]
                .toLowerCase();
        if (!RegExp(n).test(o))
          throw TypeError(
            `${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`
          );
      }
    }
  }
  class W extends q {
    constructor(t, e) {
      super(),
        (t = a(t)) &&
          ((this._element = t),
          (this._config = this._getConfig(e)),
          s.set(this._element, this.constructor.DATA_KEY, this));
    }
    dispose() {
      for (let t of (s.remove(this._element, this.constructor.DATA_KEY),
      M.off(this._element, this.constructor.EVENT_KEY),
      Object.getOwnPropertyNames(this)))
        this[t] = null;
    }
    _queueCallback(t, e, i = !0) {
      y(t, e, i);
    }
    _getConfig(t) {
      return (
        (t = this._mergeConfigObj(t, this._element)),
        (t = this._configAfterMerge(t)),
        this._typeCheckConfig(t),
        t
      );
    }
    static getInstance(t) {
      return s.get(a(t), this.DATA_KEY);
    }
    static getOrCreateInstance(t, e = {}) {
      return (
        this.getInstance(t) || new this(t, "object" == typeof e ? e : null)
      );
    }
    static get VERSION() {
      return "5.3.0";
    }
    static get DATA_KEY() {
      return `bs.${this.NAME}`;
    }
    static get EVENT_KEY() {
      return `.${this.DATA_KEY}`;
    }
    static eventName(t) {
      return `${t}${this.EVENT_KEY}`;
    }
  }
  let B = (t) => {
      let e = t.getAttribute("data-bs-target");
      if (!e || "#" === e) {
        let i = t.getAttribute("href");
        if (!i || (!i.includes("#") && !i.startsWith("."))) return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`),
          (e = i && "#" !== i ? i.trim() : null);
      }
      return r(e);
    },
    K = {
      find: (t, e = document.documentElement) =>
        [].concat(...Element.prototype.querySelectorAll.call(e, t)),
      findOne: (t, e = document.documentElement) =>
        Element.prototype.querySelector.call(e, t),
      children: (t, e) => [].concat(...t.children).filter((t) => t.matches(e)),
      parents(t, e) {
        let i = [],
          s = t.parentNode.closest(e);
        for (; s; ) i.push(s), (s = s.parentNode.closest(e));
        return i;
      },
      prev(t, e) {
        let i = t.previousElementSibling;
        for (; i; ) {
          if (i.matches(e)) return [i];
          i = i.previousElementSibling;
        }
        return [];
      },
      next(t, e) {
        let i = t.nextElementSibling;
        for (; i; ) {
          if (i.matches(e)) return [i];
          i = i.nextElementSibling;
        }
        return [];
      },
      focusableChildren(t) {
        let e = [
          "a",
          "button",
          "input",
          "textarea",
          "select",
          "details",
          "[tabindex]",
          '[contenteditable="true"]',
        ]
          .map((t) => `${t}:not([tabindex^="-"])`)
          .join(",");
        return this.find(e, t).filter((t) => !c(t) && h(t));
      },
      getSelectorFromElement(t) {
        let e = B(t);
        return e && K.findOne(e) ? e : null;
      },
      getElementFromSelector(t) {
        let e = B(t);
        return e ? K.findOne(e) : null;
      },
      getMultipleElementsFromSelector(t) {
        let e = B(t);
        return e ? K.find(e) : [];
      },
    },
    V = (t, e = "hide") => {
      let i = `click.dismiss${t.EVENT_KEY}`,
        s = t.NAME;
      M.on(document, i, `[data-bs-dismiss="${s}"]`, function (i) {
        if (
          (["A", "AREA"].includes(this.tagName) && i.preventDefault(), c(this))
        )
          return;
        let n = K.getElementFromSelector(this) || this.closest(`.${s}`);
        t.getOrCreateInstance(n)[e]();
      });
    };
  class R extends W {
    static get NAME() {
      return "alert";
    }
    close() {
      if (M.trigger(this._element, "close.bs.alert").defaultPrevented) return;
      this._element.classList.remove("show");
      let t = this._element.classList.contains("fade");
      this._queueCallback(() => this._destroyElement(), this._element, t);
    }
    _destroyElement() {
      this._element.remove(),
        M.trigger(this._element, "closed.bs.alert"),
        this.dispose();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = R.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  V(R, "close"), b(R);
  let Q = '[data-bs-toggle="button"]';
  class X extends W {
    static get NAME() {
      return "button";
    }
    toggle() {
      this._element.setAttribute(
        "aria-pressed",
        this._element.classList.toggle("active")
      );
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = X.getOrCreateInstance(this);
        "toggle" === t && e[t]();
      });
    }
  }
  M.on(document, "click.bs.button.data-api", Q, (t) => {
    t.preventDefault();
    let e = t.target.closest(Q);
    X.getOrCreateInstance(e).toggle();
  }),
    b(X);
  let Y = { endCallback: null, leftCallback: null, rightCallback: null },
    U = {
      endCallback: "(function|null)",
      leftCallback: "(function|null)",
      rightCallback: "(function|null)",
    };
  class G extends q {
    constructor(t, e) {
      super(),
        (this._element = t),
        t &&
          G.isSupported() &&
          ((this._config = this._getConfig(e)),
          (this._deltaX = 0),
          (this._supportPointerEvents = Boolean(window.PointerEvent)),
          this._initEvents());
    }
    static get Default() {
      return Y;
    }
    static get DefaultType() {
      return U;
    }
    static get NAME() {
      return "swipe";
    }
    dispose() {
      M.off(this._element, ".bs.swipe");
    }
    _start(t) {
      this._supportPointerEvents
        ? this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)
        : (this._deltaX = t.touches[0].clientX);
    }
    _end(t) {
      this._eventIsPointerPenTouch(t) &&
        (this._deltaX = t.clientX - this._deltaX),
        this._handleSwipe(),
        v(this._config.endCallback);
    }
    _move(t) {
      this._deltaX =
        t.touches && t.touches.length > 1
          ? 0
          : t.touches[0].clientX - this._deltaX;
    }
    _handleSwipe() {
      let t = Math.abs(this._deltaX);
      if (t <= 40) return;
      let e = t / this._deltaX;
      (this._deltaX = 0),
        e && v(e > 0 ? this._config.rightCallback : this._config.leftCallback);
    }
    _initEvents() {
      this._supportPointerEvents
        ? (M.on(this._element, "pointerdown.bs.swipe", (t) => this._start(t)),
          M.on(this._element, "pointerup.bs.swipe", (t) => this._end(t)),
          this._element.classList.add("pointer-event"))
        : (M.on(this._element, "touchstart.bs.swipe", (t) => this._start(t)),
          M.on(this._element, "touchmove.bs.swipe", (t) => this._move(t)),
          M.on(this._element, "touchend.bs.swipe", (t) => this._end(t)));
    }
    _eventIsPointerPenTouch(t) {
      return (
        this._supportPointerEvents &&
        ("pen" === t.pointerType || "touch" === t.pointerType)
      );
    }
    static isSupported() {
      return (
        "ontouchstart" in document.documentElement ||
        navigator.maxTouchPoints > 0
      );
    }
  }
  let Z = "next",
    J = "prev",
    tt = "left",
    te = "right",
    ti = "slid.bs.carousel",
    ts = "carousel",
    tn = "active",
    tr = { ArrowLeft: te, ArrowRight: tt },
    to = {
      interval: 5e3,
      keyboard: !0,
      pause: "hover",
      ride: !1,
      touch: !0,
      wrap: !0,
    },
    tl = {
      interval: "(number|boolean)",
      keyboard: "boolean",
      pause: "(string|boolean)",
      ride: "(boolean|string)",
      touch: "boolean",
      wrap: "boolean",
    };
  class ta extends W {
    constructor(t, e) {
      super(t, e),
        (this._interval = null),
        (this._activeElement = null),
        (this._isSliding = !1),
        (this.touchTimeout = null),
        (this._swipeHelper = null),
        (this._indicatorsElement = K.findOne(
          ".carousel-indicators",
          this._element
        )),
        this._addEventListeners(),
        this._config.ride === ts && this.cycle();
    }
    static get Default() {
      return to;
    }
    static get DefaultType() {
      return tl;
    }
    static get NAME() {
      return "carousel";
    }
    next() {
      this._slide(Z);
    }
    nextWhenVisible() {
      !document.hidden && h(this._element) && this.next();
    }
    prev() {
      this._slide(J);
    }
    pause() {
      this._isSliding && o(this._element), this._clearInterval();
    }
    cycle() {
      this._clearInterval(),
        this._updateInterval(),
        (this._interval = setInterval(
          () => this.nextWhenVisible(),
          this._config.interval
        ));
    }
    _maybeEnableCycle() {
      this._config.ride &&
        (this._isSliding
          ? M.one(this._element, ti, () => this.cycle())
          : this.cycle());
    }
    to(t) {
      let e = this._getItems();
      if (t > e.length - 1 || t < 0) return;
      if (this._isSliding)
        return void M.one(this._element, ti, () => this.to(t));
      let i = this._getItemIndex(this._getActive());
      i !== t && this._slide(t > i ? Z : J, e[t]);
    }
    dispose() {
      this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
    }
    _configAfterMerge(t) {
      return (t.defaultInterval = t.interval), t;
    }
    _addEventListeners() {
      this._config.keyboard &&
        M.on(this._element, "keydown.bs.carousel", (t) => this._keydown(t)),
        "hover" === this._config.pause &&
          (M.on(this._element, "mouseenter.bs.carousel", () => this.pause()),
          M.on(this._element, "mouseleave.bs.carousel", () =>
            this._maybeEnableCycle()
          )),
        this._config.touch && G.isSupported() && this._addTouchEventListeners();
    }
    _addTouchEventListeners() {
      for (let t of K.find(".carousel-item img", this._element))
        M.on(t, "dragstart.bs.carousel", (t) => t.preventDefault());
      this._swipeHelper = new G(this._element, {
        leftCallback: () => this._slide(this._directionToOrder(tt)),
        rightCallback: () => this._slide(this._directionToOrder(te)),
        endCallback: () => {
          "hover" === this._config.pause &&
            (this.pause(),
            this.touchTimeout && clearTimeout(this.touchTimeout),
            (this.touchTimeout = setTimeout(
              () => this._maybeEnableCycle(),
              500 + this._config.interval
            )));
        },
      });
    }
    _keydown(t) {
      if (/input|textarea/i.test(t.target.tagName)) return;
      let e = tr[t.key];
      e && (t.preventDefault(), this._slide(this._directionToOrder(e)));
    }
    _getItemIndex(t) {
      return this._getItems().indexOf(t);
    }
    _setActiveIndicatorElement(t) {
      if (!this._indicatorsElement) return;
      let e = K.findOne(".active", this._indicatorsElement);
      e.classList.remove(tn), e.removeAttribute("aria-current");
      let i = K.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
      i && (i.classList.add(tn), i.setAttribute("aria-current", "true"));
    }
    _updateInterval() {
      let t = this._activeElement || this._getActive();
      if (!t) return;
      let e = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
      this._config.interval = e || this._config.defaultInterval;
    }
    _slide(t, e = null) {
      if (this._isSliding) return;
      let i = this._getActive(),
        s = t === Z,
        n = e || w(this._getItems(), i, s, this._config.wrap);
      if (n === i) return;
      let r = this._getItemIndex(n),
        o = (e) =>
          M.trigger(this._element, e, {
            relatedTarget: n,
            direction: this._orderToDirection(t),
            from: this._getItemIndex(i),
            to: r,
          });
      if (o("slide.bs.carousel").defaultPrevented || !i || !n) return;
      let l = Boolean(this._interval);
      this.pause(),
        (this._isSliding = !0),
        this._setActiveIndicatorElement(r),
        (this._activeElement = n);
      let a = s ? "carousel-item-start" : "carousel-item-end",
        h = s ? "carousel-item-next" : "carousel-item-prev";
      n.classList.add(h),
        g(n),
        i.classList.add(a),
        n.classList.add(a),
        this._queueCallback(
          () => {
            n.classList.remove(a, h),
              n.classList.add(tn),
              i.classList.remove(tn, h, a),
              (this._isSliding = !1),
              o(ti);
          },
          i,
          this._isAnimated()
        ),
        l && this.cycle();
    }
    _isAnimated() {
      return this._element.classList.contains("slide");
    }
    _getActive() {
      return K.findOne(".active.carousel-item", this._element);
    }
    _getItems() {
      return K.find(".carousel-item", this._element);
    }
    _clearInterval() {
      this._interval &&
        (clearInterval(this._interval), (this._interval = null));
    }
    _directionToOrder(t) {
      return m() ? (t === tt ? J : Z) : t === tt ? Z : J;
    }
    _orderToDirection(t) {
      return m() ? (t === J ? tt : te) : t === J ? te : tt;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = ta.getOrCreateInstance(this, t);
        if ("number" != typeof t) {
          if ("string" == typeof t) {
            if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
              throw TypeError(`No method named "${t}"`);
            e[t]();
          }
        } else e.to(t);
      });
    }
  }
  M.on(
    document,
    "click.bs.carousel.data-api",
    "[data-bs-slide], [data-bs-slide-to]",
    function (t) {
      let e = K.getElementFromSelector(this);
      if (!e || !e.classList.contains(ts)) return;
      t.preventDefault();
      let i = ta.getOrCreateInstance(e),
        s = this.getAttribute("data-bs-slide-to");
      return s
        ? (i.to(s), void i._maybeEnableCycle())
        : "next" === H.getDataAttribute(this, "slide")
        ? (i.next(), void i._maybeEnableCycle())
        : (i.prev(), void i._maybeEnableCycle());
    }
  ),
    M.on(window, "load.bs.carousel.data-api", () => {
      let t = K.find('[data-bs-ride="carousel"]');
      for (let e of t) ta.getOrCreateInstance(e);
    }),
    b(ta);
  let th = "show",
    tc = "collapse",
    td = "collapsing",
    tu = '[data-bs-toggle="collapse"]',
    t8 = { parent: null, toggle: !0 },
    tg = { parent: "(null|element)", toggle: "boolean" };
  class tf extends W {
    constructor(t, e) {
      super(t, e), (this._isTransitioning = !1), (this._triggerArray = []);
      let i = K.find(tu);
      for (let s of i) {
        let n = K.getSelectorFromElement(s),
          r = K.find(n).filter((t) => t === this._element);
        null !== n && r.length && this._triggerArray.push(s);
      }
      this._initializeChildren(),
        this._config.parent ||
          this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
        this._config.toggle && this.toggle();
    }
    static get Default() {
      return t8;
    }
    static get DefaultType() {
      return tg;
    }
    static get NAME() {
      return "collapse";
    }
    toggle() {
      this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (this._isTransitioning || this._isShown()) return;
      let t = [];
      if (
        (this._config.parent &&
          (t = this._getFirstLevelChildren(
            ".collapse.show, .collapse.collapsing"
          )
            .filter((t) => t !== this._element)
            .map((t) => tf.getOrCreateInstance(t, { toggle: !1 }))),
        (t.length && t[0]._isTransitioning) ||
          M.trigger(this._element, "show.bs.collapse").defaultPrevented)
      )
        return;
      for (let e of t) e.hide();
      let i = this._getDimension();
      this._element.classList.remove(tc),
        this._element.classList.add(td),
        (this._element.style[i] = 0),
        this._addAriaAndCollapsedClass(this._triggerArray, !0),
        (this._isTransitioning = !0);
      let s = `scroll${i[0].toUpperCase() + i.slice(1)}`;
      this._queueCallback(
        () => {
          (this._isTransitioning = !1),
            this._element.classList.remove(td),
            this._element.classList.add(tc, th),
            (this._element.style[i] = ""),
            M.trigger(this._element, "shown.bs.collapse");
        },
        this._element,
        !0
      ),
        (this._element.style[i] = `${this._element[s]}px`);
    }
    hide() {
      if (
        this._isTransitioning ||
        !this._isShown() ||
        M.trigger(this._element, "hide.bs.collapse").defaultPrevented
      )
        return;
      let t = this._getDimension();
      for (let e of ((this._element.style[t] = `${
        this._element.getBoundingClientRect()[t]
      }px`),
      g(this._element),
      this._element.classList.add(td),
      this._element.classList.remove(tc, th),
      this._triggerArray)) {
        let i = K.getElementFromSelector(e);
        i && !this._isShown(i) && this._addAriaAndCollapsedClass([e], !1);
      }
      (this._isTransitioning = !0),
        (this._element.style[t] = ""),
        this._queueCallback(
          () => {
            (this._isTransitioning = !1),
              this._element.classList.remove(td),
              this._element.classList.add(tc),
              M.trigger(this._element, "hidden.bs.collapse");
          },
          this._element,
          !0
        );
    }
    _isShown(t = this._element) {
      return t.classList.contains(th);
    }
    _configAfterMerge(t) {
      return (t.toggle = Boolean(t.toggle)), (t.parent = a(t.parent)), t;
    }
    _getDimension() {
      return this._element.classList.contains("collapse-horizontal")
        ? "width"
        : "height";
    }
    _initializeChildren() {
      if (!this._config.parent) return;
      let t = this._getFirstLevelChildren(tu);
      for (let e of t) {
        let i = K.getElementFromSelector(e);
        i && this._addAriaAndCollapsedClass([e], this._isShown(i));
      }
    }
    _getFirstLevelChildren(t) {
      let e = K.find(":scope .collapse .collapse", this._config.parent);
      return K.find(t, this._config.parent).filter((t) => !e.includes(t));
    }
    _addAriaAndCollapsedClass(t, e) {
      if (t.length)
        for (let i of t)
          i.classList.toggle("collapsed", !e),
            i.setAttribute("aria-expanded", e);
    }
    static jQueryInterface(t) {
      let e = {};
      return (
        "string" == typeof t && /show|hide/.test(t) && (e.toggle = !1),
        this.each(function () {
          let i = tf.getOrCreateInstance(this, e);
          if ("string" == typeof t) {
            if (void 0 === i[t]) throw TypeError(`No method named "${t}"`);
            i[t]();
          }
        })
      );
    }
  }
  M.on(document, "click.bs.collapse.data-api", tu, function (t) {
    for (let e of (("A" === t.target.tagName ||
      (t.delegateTarget && "A" === t.delegateTarget.tagName)) &&
      t.preventDefault(),
    K.getMultipleElementsFromSelector(this)))
      tf.getOrCreateInstance(e, { toggle: !1 }).toggle();
  }),
    b(tf);
  let tp = "dropdown",
    tm = "ArrowDown",
    tb = "click.bs.dropdown.data-api",
    tv = "keydown.bs.dropdown.data-api",
    ty = "show",
    tw = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    tA = `${tw}.show`,
    tC = ".dropdown-menu",
    tE = m() ? "top-end" : "top-start",
    tT = m() ? "top-start" : "top-end",
    tk = m() ? "bottom-end" : "bottom-start",
    tL = m() ? "bottom-start" : "bottom-end",
    t$ = m() ? "left-start" : "right-start",
    tS = m() ? "right-start" : "left-start",
    tI = {
      autoClose: !0,
      boundary: "clippingParents",
      display: "dynamic",
      offset: [0, 2],
      popperConfig: null,
      reference: "toggle",
    },
    tD = {
      autoClose: "(boolean|string)",
      boundary: "(string|element)",
      display: "string",
      offset: "(array|string|function)",
      popperConfig: "(null|object|function)",
      reference: "(string|element|object)",
    };
  class tO extends W {
    constructor(t, e) {
      super(t, e),
        (this._popper = null),
        (this._parent = this._element.parentNode),
        (this._menu =
          K.next(this._element, tC)[0] ||
          K.prev(this._element, tC)[0] ||
          K.findOne(tC, this._parent)),
        (this._inNavbar = this._detectNavbar());
    }
    static get Default() {
      return tI;
    }
    static get DefaultType() {
      return tD;
    }
    static get NAME() {
      return tp;
    }
    toggle() {
      return this._isShown() ? this.hide() : this.show();
    }
    show() {
      if (c(this._element) || this._isShown()) return;
      let t = { relatedTarget: this._element };
      if (!M.trigger(this._element, "show.bs.dropdown", t).defaultPrevented) {
        if (
          (this._createPopper(),
          "ontouchstart" in document.documentElement &&
            !this._parent.closest(".navbar-nav"))
        )
          for (let e of [].concat(...document.body.children))
            M.on(e, "mouseover", u);
        this._element.focus(),
          this._element.setAttribute("aria-expanded", !0),
          this._menu.classList.add(ty),
          this._element.classList.add(ty),
          M.trigger(this._element, "shown.bs.dropdown", t);
      }
    }
    hide() {
      if (c(this._element) || !this._isShown()) return;
      let t = { relatedTarget: this._element };
      this._completeHide(t);
    }
    dispose() {
      this._popper && this._popper.destroy(), super.dispose();
    }
    update() {
      (this._inNavbar = this._detectNavbar()),
        this._popper && this._popper.update();
    }
    _completeHide(t) {
      if (!M.trigger(this._element, "hide.bs.dropdown", t).defaultPrevented) {
        if ("ontouchstart" in document.documentElement)
          for (let e of [].concat(...document.body.children))
            M.off(e, "mouseover", u);
        this._popper && this._popper.destroy(),
          this._menu.classList.remove(ty),
          this._element.classList.remove(ty),
          this._element.setAttribute("aria-expanded", "false"),
          H.removeDataAttribute(this._menu, "popper"),
          M.trigger(this._element, "hidden.bs.dropdown", t);
      }
    }
    _getConfig(t) {
      if (
        "object" == typeof (t = super._getConfig(t)).reference &&
        !l(t.reference) &&
        "function" != typeof t.reference.getBoundingClientRect
      )
        throw TypeError(
          `${tp.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`
        );
      return t;
    }
    _createPopper() {
      if (void 0 === e)
        throw TypeError(
          "Bootstrap's dropdowns require Popper (https://popper.js.org)"
        );
      let t = this._element;
      "parent" === this._config.reference
        ? (t = this._parent)
        : l(this._config.reference)
        ? (t = a(this._config.reference))
        : "object" == typeof this._config.reference &&
          (t = this._config.reference);
      let i = this._getPopperConfig();
      this._popper = e.createPopper(t, this._menu, i);
    }
    _isShown() {
      return this._menu.classList.contains(ty);
    }
    _getPlacement() {
      let t = this._parent;
      if (t.classList.contains("dropend")) return t$;
      if (t.classList.contains("dropstart")) return tS;
      if (t.classList.contains("dropup-center")) return "top";
      if (t.classList.contains("dropdown-center")) return "bottom";
      let e =
        "end" ===
        getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
      return t.classList.contains("dropup") ? (e ? tT : tE) : e ? tL : tk;
    }
    _detectNavbar() {
      return null !== this._element.closest(".navbar");
    }
    _getOffset() {
      let { offset: t } = this._config;
      return "string" == typeof t
        ? t.split(",").map((t) => Number.parseInt(t, 10))
        : "function" == typeof t
        ? (e) => t(e, this._element)
        : t;
    }
    _getPopperConfig() {
      let t = {
        placement: this._getPlacement(),
        modifiers: [
          {
            name: "preventOverflow",
            options: { boundary: this._config.boundary },
          },
          { name: "offset", options: { offset: this._getOffset() } },
        ],
      };
      return (
        (this._inNavbar || "static" === this._config.display) &&
          (H.setDataAttribute(this._menu, "popper", "static"),
          (t.modifiers = [{ name: "applyStyles", enabled: !1 }])),
        { ...t, ...v(this._config.popperConfig, [t]) }
      );
    }
    _selectMenuItem({ key: t, target: e }) {
      let i = K.find(
        ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
        this._menu
      ).filter((t) => h(t));
      i.length && w(i, e, t === tm, !i.includes(e)).focus();
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = tO.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
    static clearMenus(t) {
      if (2 === t.button || ("keyup" === t.type && "Tab" !== t.key)) return;
      let e = K.find(tA);
      for (let i of e) {
        let s = tO.getInstance(i);
        if (!s || !1 === s._config.autoClose) continue;
        let n = t.composedPath(),
          r = n.includes(s._menu);
        if (
          n.includes(s._element) ||
          ("inside" === s._config.autoClose && !r) ||
          ("outside" === s._config.autoClose && r) ||
          (s._menu.contains(t.target) &&
            (("keyup" === t.type && "Tab" === t.key) ||
              /input|select|option|textarea|form/i.test(t.target.tagName)))
        )
          continue;
        let o = { relatedTarget: s._element };
        "click" === t.type && (o.clickEvent = t), s._completeHide(o);
      }
    }
    static dataApiKeydownHandler(t) {
      let e = /input|textarea/i.test(t.target.tagName),
        i = "Escape" === t.key,
        s = ["ArrowUp", tm].includes(t.key);
      if ((!s && !i) || (e && !i)) return;
      t.preventDefault();
      let n = this.matches(tw)
          ? this
          : K.prev(this, tw)[0] ||
            K.next(this, tw)[0] ||
            K.findOne(tw, t.delegateTarget.parentNode),
        r = tO.getOrCreateInstance(n);
      if (s) return t.stopPropagation(), r.show(), void r._selectMenuItem(t);
      r._isShown() && (t.stopPropagation(), r.hide(), n.focus());
    }
  }
  M.on(document, tv, tw, tO.dataApiKeydownHandler),
    M.on(document, tv, tC, tO.dataApiKeydownHandler),
    M.on(document, tb, tO.clearMenus),
    M.on(document, "keyup.bs.dropdown.data-api", tO.clearMenus),
    M.on(document, tb, tw, function (t) {
      t.preventDefault(), tO.getOrCreateInstance(this).toggle();
    }),
    b(tO);
  let tN = "show",
    tP = "mousedown.bs.backdrop",
    tx = {
      className: "modal-backdrop",
      clickCallback: null,
      isAnimated: !1,
      isVisible: !0,
      rootElement: "body",
    },
    t_ = {
      className: "string",
      clickCallback: "(function|null)",
      isAnimated: "boolean",
      isVisible: "boolean",
      rootElement: "(element|string)",
    };
  class tM extends q {
    constructor(t) {
      super(),
        (this._config = this._getConfig(t)),
        (this._isAppended = !1),
        (this._element = null);
    }
    static get Default() {
      return tx;
    }
    static get DefaultType() {
      return t_;
    }
    static get NAME() {
      return "backdrop";
    }
    show(t) {
      if (!this._config.isVisible) return void v(t);
      this._append();
      let e = this._getElement();
      this._config.isAnimated && g(e),
        e.classList.add(tN),
        this._emulateAnimation(() => {
          v(t);
        });
    }
    hide(t) {
      this._config.isVisible
        ? (this._getElement().classList.remove(tN),
          this._emulateAnimation(() => {
            this.dispose(), v(t);
          }))
        : v(t);
    }
    dispose() {
      this._isAppended &&
        (M.off(this._element, tP),
        this._element.remove(),
        (this._isAppended = !1));
    }
    _getElement() {
      if (!this._element) {
        let t = document.createElement("div");
        (t.className = this._config.className),
          this._config.isAnimated && t.classList.add("fade"),
          (this._element = t);
      }
      return this._element;
    }
    _configAfterMerge(t) {
      return (t.rootElement = a(t.rootElement)), t;
    }
    _append() {
      if (this._isAppended) return;
      let t = this._getElement();
      this._config.rootElement.append(t),
        M.on(t, tP, () => {
          v(this._config.clickCallback);
        }),
        (this._isAppended = !0);
    }
    _emulateAnimation(t) {
      y(t, this._getElement(), this._config.isAnimated);
    }
  }
  let tF = ".bs.focustrap",
    tj = "backward",
    t9 = { autofocus: !0, trapElement: null },
    tz = { autofocus: "boolean", trapElement: "element" };
  class tH extends q {
    constructor(t) {
      super(),
        (this._config = this._getConfig(t)),
        (this._isActive = !1),
        (this._lastTabNavDirection = null);
    }
    static get Default() {
      return t9;
    }
    static get DefaultType() {
      return tz;
    }
    static get NAME() {
      return "focustrap";
    }
    activate() {
      this._isActive ||
        (this._config.autofocus && this._config.trapElement.focus(),
        M.off(document, tF),
        M.on(document, "focusin.bs.focustrap", (t) => this._handleFocusin(t)),
        M.on(document, "keydown.tab.bs.focustrap", (t) =>
          this._handleKeydown(t)
        ),
        (this._isActive = !0));
    }
    deactivate() {
      this._isActive && ((this._isActive = !1), M.off(document, tF));
    }
    _handleFocusin(t) {
      let { trapElement: e } = this._config;
      if (t.target === document || t.target === e || e.contains(t.target))
        return;
      let i = K.focusableChildren(e);
      0 === i.length
        ? e.focus()
        : this._lastTabNavDirection === tj
        ? i[i.length - 1].focus()
        : i[0].focus();
    }
    _handleKeydown(t) {
      "Tab" === t.key &&
        (this._lastTabNavDirection = t.shiftKey ? tj : "forward");
    }
  }
  let tq = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    tW = ".sticky-top",
    tB = "padding-right",
    tK = "margin-right";
  class tV {
    constructor() {
      this._element = document.body;
    }
    getWidth() {
      let t = document.documentElement.clientWidth;
      return Math.abs(window.innerWidth - t);
    }
    hide() {
      let t = this.getWidth();
      this._disableOverFlow(),
        this._setElementAttributes(this._element, tB, (e) => e + t),
        this._setElementAttributes(tq, tB, (e) => e + t),
        this._setElementAttributes(tW, tK, (e) => e - t);
    }
    reset() {
      this._resetElementAttributes(this._element, "overflow"),
        this._resetElementAttributes(this._element, tB),
        this._resetElementAttributes(tq, tB),
        this._resetElementAttributes(tW, tK);
    }
    isOverflowing() {
      return this.getWidth() > 0;
    }
    _disableOverFlow() {
      this._saveInitialAttribute(this._element, "overflow"),
        (this._element.style.overflow = "hidden");
    }
    _setElementAttributes(t, e, i) {
      let s = this.getWidth();
      this._applyManipulationCallback(t, (t) => {
        if (t !== this._element && window.innerWidth > t.clientWidth + s)
          return;
        this._saveInitialAttribute(t, e);
        let n = window.getComputedStyle(t).getPropertyValue(e);
        t.style.setProperty(e, `${i(Number.parseFloat(n))}px`);
      });
    }
    _saveInitialAttribute(t, e) {
      let i = t.style.getPropertyValue(e);
      i && H.setDataAttribute(t, e, i);
    }
    _resetElementAttributes(t, e) {
      this._applyManipulationCallback(t, (t) => {
        let i = H.getDataAttribute(t, e);
        null !== i
          ? (H.removeDataAttribute(t, e), t.style.setProperty(e, i))
          : t.style.removeProperty(e);
      });
    }
    _applyManipulationCallback(t, e) {
      if (l(t)) e(t);
      else for (let i of K.find(t, this._element)) e(i);
    }
  }
  let tR = ".bs.modal",
    tQ = "hidden.bs.modal",
    tX = "show.bs.modal",
    tY = "modal-open",
    tU = "show",
    t1 = "modal-static",
    t3 = { backdrop: !0, focus: !0, keyboard: !0 },
    t0 = {
      backdrop: "(boolean|string)",
      focus: "boolean",
      keyboard: "boolean",
    };
  class t4 extends W {
    constructor(t, e) {
      super(t, e),
        (this._dialog = K.findOne(".modal-dialog", this._element)),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        (this._isShown = !1),
        (this._isTransitioning = !1),
        (this._scrollBar = new tV()),
        this._addEventListeners();
    }
    static get Default() {
      return t3;
    }
    static get DefaultType() {
      return t0;
    }
    static get NAME() {
      return "modal";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown ||
        this._isTransitioning ||
        M.trigger(this._element, tX, { relatedTarget: t }).defaultPrevented ||
        ((this._isShown = !0),
        (this._isTransitioning = !0),
        this._scrollBar.hide(),
        document.body.classList.add(tY),
        this._adjustDialog(),
        this._backdrop.show(() => this._showElement(t)));
    }
    hide() {
      this._isShown &&
        !this._isTransitioning &&
        (M.trigger(this._element, "hide.bs.modal").defaultPrevented ||
          ((this._isShown = !1),
          (this._isTransitioning = !0),
          this._focustrap.deactivate(),
          this._element.classList.remove(tU),
          this._queueCallback(
            () => this._hideModal(),
            this._element,
            this._isAnimated()
          )));
    }
    dispose() {
      M.off(window, tR),
        M.off(this._dialog, tR),
        this._backdrop.dispose(),
        this._focustrap.deactivate(),
        super.dispose();
    }
    handleUpdate() {
      this._adjustDialog();
    }
    _initializeBackDrop() {
      return new tM({
        isVisible: Boolean(this._config.backdrop),
        isAnimated: this._isAnimated(),
      });
    }
    _initializeFocusTrap() {
      return new tH({ trapElement: this._element });
    }
    _showElement(t) {
      document.body.contains(this._element) ||
        document.body.append(this._element),
        (this._element.style.display = "block"),
        this._element.removeAttribute("aria-hidden"),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        (this._element.scrollTop = 0);
      let e = K.findOne(".modal-body", this._dialog);
      e && (e.scrollTop = 0),
        g(this._element),
        this._element.classList.add(tU),
        this._queueCallback(
          () => {
            this._config.focus && this._focustrap.activate(),
              (this._isTransitioning = !1),
              M.trigger(this._element, "shown.bs.modal", { relatedTarget: t });
          },
          this._dialog,
          this._isAnimated()
        );
    }
    _addEventListeners() {
      M.on(this._element, "keydown.dismiss.bs.modal", (t) => {
        "Escape" === t.key &&
          (this._config.keyboard
            ? this.hide()
            : this._triggerBackdropTransition());
      }),
        M.on(window, "resize.bs.modal", () => {
          this._isShown && !this._isTransitioning && this._adjustDialog();
        }),
        M.on(this._element, "mousedown.dismiss.bs.modal", (t) => {
          M.one(this._element, "click.dismiss.bs.modal", (e) => {
            this._element === t.target &&
              this._element === e.target &&
              ("static" !== this._config.backdrop
                ? this._config.backdrop && this.hide()
                : this._triggerBackdropTransition());
          });
        });
    }
    _hideModal() {
      (this._element.style.display = "none"),
        this._element.setAttribute("aria-hidden", !0),
        this._element.removeAttribute("aria-modal"),
        this._element.removeAttribute("role"),
        (this._isTransitioning = !1),
        this._backdrop.hide(() => {
          document.body.classList.remove(tY),
            this._resetAdjustments(),
            this._scrollBar.reset(),
            M.trigger(this._element, tQ);
        });
    }
    _isAnimated() {
      return this._element.classList.contains("fade");
    }
    _triggerBackdropTransition() {
      if (M.trigger(this._element, "hidePrevented.bs.modal").defaultPrevented)
        return;
      let t =
          this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._element.style.overflowY;
      "hidden" === e ||
        this._element.classList.contains(t1) ||
        (t || (this._element.style.overflowY = "hidden"),
        this._element.classList.add(t1),
        this._queueCallback(() => {
          this._element.classList.remove(t1),
            this._queueCallback(() => {
              this._element.style.overflowY = e;
            }, this._dialog);
        }, this._dialog),
        this._element.focus());
    }
    _adjustDialog() {
      let t =
          this._element.scrollHeight > document.documentElement.clientHeight,
        e = this._scrollBar.getWidth(),
        i = e > 0;
      if (i && !t) {
        let s = m() ? "paddingLeft" : "paddingRight";
        this._element.style[s] = `${e}px`;
      }
      if (!i && t) {
        let n = m() ? "paddingRight" : "paddingLeft";
        this._element.style[n] = `${e}px`;
      }
    }
    _resetAdjustments() {
      (this._element.style.paddingLeft = ""),
        (this._element.style.paddingRight = "");
    }
    static jQueryInterface(t, e) {
      return this.each(function () {
        let i = t4.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === i[t]) throw TypeError(`No method named "${t}"`);
          i[t](e);
        }
      });
    }
  }
  M.on(
    document,
    "click.bs.modal.data-api",
    '[data-bs-toggle="modal"]',
    function (t) {
      let e = K.getElementFromSelector(this);
      ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
        M.one(e, tX, (t) => {
          t.defaultPrevented ||
            M.one(e, tQ, () => {
              h(this) && this.focus();
            });
        });
      let i = K.findOne(".modal.show");
      i && t4.getInstance(i).hide(), t4.getOrCreateInstance(e).toggle(this);
    }
  ),
    V(t4),
    b(t4);
  let t2 = "show",
    tG = "showing",
    tZ = "hiding",
    t6 = ".offcanvas.show",
    t7 = "hidePrevented.bs.offcanvas",
    tJ = "hidden.bs.offcanvas",
    t5 = { backdrop: !0, keyboard: !0, scroll: !1 },
    et = {
      backdrop: "(boolean|string)",
      keyboard: "boolean",
      scroll: "boolean",
    };
  class ee extends W {
    constructor(t, e) {
      super(t, e),
        (this._isShown = !1),
        (this._backdrop = this._initializeBackDrop()),
        (this._focustrap = this._initializeFocusTrap()),
        this._addEventListeners();
    }
    static get Default() {
      return t5;
    }
    static get DefaultType() {
      return et;
    }
    static get NAME() {
      return "offcanvas";
    }
    toggle(t) {
      return this._isShown ? this.hide() : this.show(t);
    }
    show(t) {
      this._isShown ||
        M.trigger(this._element, "show.bs.offcanvas", { relatedTarget: t })
          .defaultPrevented ||
        ((this._isShown = !0),
        this._backdrop.show(),
        this._config.scroll || new tV().hide(),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        this._element.classList.add(tG),
        this._queueCallback(
          () => {
            (this._config.scroll && !this._config.backdrop) ||
              this._focustrap.activate(),
              this._element.classList.add(t2),
              this._element.classList.remove(tG),
              M.trigger(this._element, "shown.bs.offcanvas", {
                relatedTarget: t,
              });
          },
          this._element,
          !0
        ));
    }
    hide() {
      this._isShown &&
        (M.trigger(this._element, "hide.bs.offcanvas").defaultPrevented ||
          (this._focustrap.deactivate(),
          this._element.blur(),
          (this._isShown = !1),
          this._element.classList.add(tZ),
          this._backdrop.hide(),
          this._queueCallback(
            () => {
              this._element.classList.remove(t2, tZ),
                this._element.removeAttribute("aria-modal"),
                this._element.removeAttribute("role"),
                this._config.scroll || new tV().reset(),
                M.trigger(this._element, tJ);
            },
            this._element,
            !0
          )));
    }
    dispose() {
      this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
    }
    _initializeBackDrop() {
      let t = Boolean(this._config.backdrop);
      return new tM({
        className: "offcanvas-backdrop",
        isVisible: t,
        isAnimated: !0,
        rootElement: this._element.parentNode,
        clickCallback: t
          ? () => {
              "static" !== this._config.backdrop
                ? this.hide()
                : M.trigger(this._element, t7);
            }
          : null,
      });
    }
    _initializeFocusTrap() {
      return new tH({ trapElement: this._element });
    }
    _addEventListeners() {
      M.on(this._element, "keydown.dismiss.bs.offcanvas", (t) => {
        "Escape" === t.key &&
          (this._config.keyboard ? this.hide() : M.trigger(this._element, t7));
      });
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = ee.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  M.on(
    document,
    "click.bs.offcanvas.data-api",
    '[data-bs-toggle="offcanvas"]',
    function (t) {
      let e = K.getElementFromSelector(this);
      if ((["A", "AREA"].includes(this.tagName) && t.preventDefault(), c(this)))
        return;
      M.one(e, tJ, () => {
        h(this) && this.focus();
      });
      let i = K.findOne(t6);
      i && i !== e && ee.getInstance(i).hide(),
        ee.getOrCreateInstance(e).toggle(this);
    }
  ),
    M.on(window, "load.bs.offcanvas.data-api", () => {
      for (let t of K.find(t6)) ee.getOrCreateInstance(t).show();
    }),
    M.on(window, "resize.bs.offcanvas", () => {
      for (let t of K.find("[aria-modal][class*=show][class*=offcanvas-]"))
        "fixed" !== getComputedStyle(t).position &&
          ee.getOrCreateInstance(t).hide();
    }),
    V(ee),
    b(ee);
  let ei = {
      "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i],
      a: ["target", "href", "title", "rel"],
      area: [],
      b: [],
      br: [],
      col: [],
      code: [],
      div: [],
      em: [],
      hr: [],
      h1: [],
      h2: [],
      h3: [],
      h4: [],
      h5: [],
      h6: [],
      i: [],
      img: ["src", "srcset", "alt", "title", "width", "height"],
      li: [],
      ol: [],
      p: [],
      pre: [],
      s: [],
      small: [],
      span: [],
      sub: [],
      sup: [],
      strong: [],
      u: [],
      ul: [],
    },
    es = new Set([
      "background",
      "cite",
      "href",
      "itemtype",
      "longdesc",
      "poster",
      "src",
      "xlink:href",
    ]),
    en = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i,
    er = (t, e) => {
      let i = t.nodeName.toLowerCase();
      return e.includes(i)
        ? !es.has(i) || Boolean(en.test(t.nodeValue))
        : e.filter((t) => t instanceof RegExp).some((t) => t.test(i));
    },
    eo = {
      allowList: ei,
      content: {},
      extraClass: "",
      html: !1,
      sanitize: !0,
      sanitizeFn: null,
      template: "<div></div>",
    },
    el = {
      allowList: "object",
      content: "object",
      extraClass: "(string|function)",
      html: "boolean",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      template: "string",
    },
    ea = {
      entry: "(string|element|function|null)",
      selector: "(string|element)",
    };
  class eh extends q {
    constructor(t) {
      super(), (this._config = this._getConfig(t));
    }
    static get Default() {
      return eo;
    }
    static get DefaultType() {
      return el;
    }
    static get NAME() {
      return "TemplateFactory";
    }
    getContent() {
      return Object.values(this._config.content)
        .map((t) => this._resolvePossibleFunction(t))
        .filter(Boolean);
    }
    hasContent() {
      return this.getContent().length > 0;
    }
    changeContent(t) {
      return (
        this._checkContent(t),
        (this._config.content = { ...this._config.content, ...t }),
        this
      );
    }
    toHtml() {
      let t = document.createElement("div");
      for (let [e, i] of ((t.innerHTML = this._maybeSanitize(
        this._config.template
      )),
      Object.entries(this._config.content)))
        this._setContent(t, i, e);
      let s = t.children[0],
        n = this._resolvePossibleFunction(this._config.extraClass);
      return n && s.classList.add(...n.split(" ")), s;
    }
    _typeCheckConfig(t) {
      super._typeCheckConfig(t), this._checkContent(t.content);
    }
    _checkContent(t) {
      for (let [e, i] of Object.entries(t))
        super._typeCheckConfig({ selector: e, entry: i }, ea);
    }
    _setContent(t, e, i) {
      let s = K.findOne(i, t);
      s &&
        ((e = this._resolvePossibleFunction(e))
          ? l(e)
            ? this._putElementInTemplate(a(e), s)
            : this._config.html
            ? (s.innerHTML = this._maybeSanitize(e))
            : (s.textContent = e)
          : s.remove());
    }
    _maybeSanitize(t) {
      return this._config.sanitize
        ? (function (t, e, i) {
            if (!t.length) return t;
            if (i && "function" == typeof i) return i(t);
            let s = new window.DOMParser().parseFromString(t, "text/html"),
              n = [].concat(...s.body.querySelectorAll("*"));
            for (let r of n) {
              let o = r.nodeName.toLowerCase();
              if (!Object.keys(e).includes(o)) {
                r.remove();
                continue;
              }
              let l = [].concat(...r.attributes),
                a = [].concat(e["*"] || [], e[o] || []);
              for (let h of l) er(h, a) || r.removeAttribute(h.nodeName);
            }
            return s.body.innerHTML;
          })(t, this._config.allowList, this._config.sanitizeFn)
        : t;
    }
    _resolvePossibleFunction(t) {
      return v(t, [this]);
    }
    _putElementInTemplate(t, e) {
      if (this._config.html) return (e.innerHTML = ""), void e.append(t);
      e.textContent = t.textContent;
    }
  }
  let ec = new Set(["sanitize", "allowList", "sanitizeFn"]),
    ed = "fade",
    eu = "show",
    e8 = ".modal",
    eg = "hide.bs.modal",
    ef = "hover",
    ep = "focus",
    em = {
      AUTO: "auto",
      TOP: "top",
      RIGHT: m() ? "left" : "right",
      BOTTOM: "bottom",
      LEFT: m() ? "right" : "left",
    },
    eb = {
      allowList: ei,
      animation: !0,
      boundary: "clippingParents",
      container: !1,
      customClass: "",
      delay: 0,
      fallbackPlacements: ["top", "right", "bottom", "left"],
      html: !1,
      offset: [0, 6],
      placement: "top",
      popperConfig: null,
      sanitize: !0,
      sanitizeFn: null,
      selector: !1,
      template:
        '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
      title: "",
      trigger: "hover focus",
    },
    ev = {
      allowList: "object",
      animation: "boolean",
      boundary: "(string|element)",
      container: "(string|element|boolean)",
      customClass: "(string|function)",
      delay: "(number|object)",
      fallbackPlacements: "array",
      html: "boolean",
      offset: "(array|string|function)",
      placement: "(string|function)",
      popperConfig: "(null|object|function)",
      sanitize: "boolean",
      sanitizeFn: "(null|function)",
      selector: "(string|boolean)",
      template: "string",
      title: "(string|element|function)",
      trigger: "string",
    };
  class ey extends W {
    constructor(t, i) {
      if (void 0 === e)
        throw TypeError(
          "Bootstrap's tooltips require Popper (https://popper.js.org)"
        );
      super(t, i),
        (this._isEnabled = !0),
        (this._timeout = 0),
        (this._isHovered = null),
        (this._activeTrigger = {}),
        (this._popper = null),
        (this._templateFactory = null),
        (this._newContent = null),
        (this.tip = null),
        this._setListeners(),
        this._config.selector || this._fixTitle();
    }
    static get Default() {
      return eb;
    }
    static get DefaultType() {
      return ev;
    }
    static get NAME() {
      return "tooltip";
    }
    enable() {
      this._isEnabled = !0;
    }
    disable() {
      this._isEnabled = !1;
    }
    toggleEnabled() {
      this._isEnabled = !this._isEnabled;
    }
    toggle() {
      this._isEnabled &&
        ((this._activeTrigger.click = !this._activeTrigger.click),
        this._isShown() ? this._leave() : this._enter());
    }
    dispose() {
      clearTimeout(this._timeout),
        M.off(this._element.closest(e8), eg, this._hideModalHandler),
        this._element.getAttribute("data-bs-original-title") &&
          this._element.setAttribute(
            "title",
            this._element.getAttribute("data-bs-original-title")
          ),
        this._disposePopper(),
        super.dispose();
    }
    show() {
      if ("none" === this._element.style.display)
        throw Error("Please use show on visible elements");
      if (!this._isWithContent() || !this._isEnabled) return;
      let t = M.trigger(this._element, this.constructor.eventName("show")),
        e = (
          d(this._element) || this._element.ownerDocument.documentElement
        ).contains(this._element);
      if (t.defaultPrevented || !e) return;
      this._disposePopper();
      let i = this._getTipElement();
      this._element.setAttribute("aria-describedby", i.getAttribute("id"));
      let { container: s } = this._config;
      if (
        (this._element.ownerDocument.documentElement.contains(this.tip) ||
          (s.append(i),
          M.trigger(this._element, this.constructor.eventName("inserted"))),
        (this._popper = this._createPopper(i)),
        i.classList.add(eu),
        "ontouchstart" in document.documentElement)
      )
        for (let n of [].concat(...document.body.children))
          M.on(n, "mouseover", u);
      this._queueCallback(
        () => {
          M.trigger(this._element, this.constructor.eventName("shown")),
            !1 === this._isHovered && this._leave(),
            (this._isHovered = !1);
        },
        this.tip,
        this._isAnimated()
      );
    }
    hide() {
      if (
        this._isShown() &&
        !M.trigger(this._element, this.constructor.eventName("hide"))
          .defaultPrevented
      ) {
        if (
          (this._getTipElement().classList.remove(eu),
          "ontouchstart" in document.documentElement)
        )
          for (let t of [].concat(...document.body.children))
            M.off(t, "mouseover", u);
        (this._activeTrigger.click = !1),
          (this._activeTrigger.focus = !1),
          (this._activeTrigger.hover = !1),
          (this._isHovered = null),
          this._queueCallback(
            () => {
              this._isWithActiveTrigger() ||
                (this._isHovered || this._disposePopper(),
                this._element.removeAttribute("aria-describedby"),
                M.trigger(this._element, this.constructor.eventName("hidden")));
            },
            this.tip,
            this._isAnimated()
          );
      }
    }
    update() {
      this._popper && this._popper.update();
    }
    _isWithContent() {
      return Boolean(this._getTitle());
    }
    _getTipElement() {
      return (
        this.tip ||
          (this.tip = this._createTipElement(
            this._newContent || this._getContentForTemplate()
          )),
        this.tip
      );
    }
    _createTipElement(t) {
      let e = this._getTemplateFactory(t).toHtml();
      if (!e) return null;
      e.classList.remove(ed, eu),
        e.classList.add(`bs-${this.constructor.NAME}-auto`);
      let i = ((t) => {
        do t += Math.floor(1e6 * Math.random());
        while (document.getElementById(t));
        return t;
      })(this.constructor.NAME).toString();
      return (
        e.setAttribute("id", i), this._isAnimated() && e.classList.add(ed), e
      );
    }
    setContent(t) {
      (this._newContent = t),
        this._isShown() && (this._disposePopper(), this.show());
    }
    _getTemplateFactory(t) {
      return (
        this._templateFactory
          ? this._templateFactory.changeContent(t)
          : (this._templateFactory = new eh({
              ...this._config,
              content: t,
              extraClass: this._resolvePossibleFunction(
                this._config.customClass
              ),
            })),
        this._templateFactory
      );
    }
    _getContentForTemplate() {
      return { ".tooltip-inner": this._getTitle() };
    }
    _getTitle() {
      return (
        this._resolvePossibleFunction(this._config.title) ||
        this._element.getAttribute("data-bs-original-title")
      );
    }
    _initializeOnDelegatedTarget(t) {
      return this.constructor.getOrCreateInstance(
        t.delegateTarget,
        this._getDelegateConfig()
      );
    }
    _isAnimated() {
      return (
        this._config.animation || (this.tip && this.tip.classList.contains(ed))
      );
    }
    _isShown() {
      return this.tip && this.tip.classList.contains(eu);
    }
    _createPopper(t) {
      let i = v(this._config.placement, [this, t, this._element]),
        s = em[i.toUpperCase()];
      return e.createPopper(this._element, t, this._getPopperConfig(s));
    }
    _getOffset() {
      let { offset: t } = this._config;
      return "string" == typeof t
        ? t.split(",").map((t) => Number.parseInt(t, 10))
        : "function" == typeof t
        ? (e) => t(e, this._element)
        : t;
    }
    _resolvePossibleFunction(t) {
      return v(t, [this._element]);
    }
    _getPopperConfig(t) {
      let e = {
        placement: t,
        modifiers: [
          {
            name: "flip",
            options: { fallbackPlacements: this._config.fallbackPlacements },
          },
          { name: "offset", options: { offset: this._getOffset() } },
          {
            name: "preventOverflow",
            options: { boundary: this._config.boundary },
          },
          {
            name: "arrow",
            options: { element: `.${this.constructor.NAME}-arrow` },
          },
          {
            name: "preSetPlacement",
            enabled: !0,
            phase: "beforeMain",
            fn: (t) => {
              this._getTipElement().setAttribute(
                "data-popper-placement",
                t.state.placement
              );
            },
          },
        ],
      };
      return { ...e, ...v(this._config.popperConfig, [e]) };
    }
    _setListeners() {
      let t = this._config.trigger.split(" ");
      for (let e of t)
        if ("click" === e)
          M.on(
            this._element,
            this.constructor.eventName("click"),
            this._config.selector,
            (t) => {
              this._initializeOnDelegatedTarget(t).toggle();
            }
          );
        else if ("manual" !== e) {
          let i =
              e === ef
                ? this.constructor.eventName("mouseenter")
                : this.constructor.eventName("focusin"),
            s =
              e === ef
                ? this.constructor.eventName("mouseleave")
                : this.constructor.eventName("focusout");
          M.on(this._element, i, this._config.selector, (t) => {
            let e = this._initializeOnDelegatedTarget(t);
            (e._activeTrigger["focusin" === t.type ? ep : ef] = !0), e._enter();
          }),
            M.on(this._element, s, this._config.selector, (t) => {
              let e = this._initializeOnDelegatedTarget(t);
              (e._activeTrigger["focusout" === t.type ? ep : ef] =
                e._element.contains(t.relatedTarget)),
                e._leave();
            });
        }
      (this._hideModalHandler = () => {
        this._element && this.hide();
      }),
        M.on(this._element.closest(e8), eg, this._hideModalHandler);
    }
    _fixTitle() {
      let t = this._element.getAttribute("title");
      t &&
        (this._element.getAttribute("aria-label") ||
          this._element.textContent.trim() ||
          this._element.setAttribute("aria-label", t),
        this._element.setAttribute("data-bs-original-title", t),
        this._element.removeAttribute("title"));
    }
    _enter() {
      this._isShown() || this._isHovered
        ? (this._isHovered = !0)
        : ((this._isHovered = !0),
          this._setTimeout(() => {
            this._isHovered && this.show();
          }, this._config.delay.show));
    }
    _leave() {
      this._isWithActiveTrigger() ||
        ((this._isHovered = !1),
        this._setTimeout(() => {
          this._isHovered || this.hide();
        }, this._config.delay.hide));
    }
    _setTimeout(t, e) {
      clearTimeout(this._timeout), (this._timeout = setTimeout(t, e));
    }
    _isWithActiveTrigger() {
      return Object.values(this._activeTrigger).includes(!0);
    }
    _getConfig(t) {
      let e = H.getDataAttributes(this._element);
      for (let i of Object.keys(e)) ec.has(i) && delete e[i];
      return (
        (t = { ...e, ...("object" == typeof t && t ? t : {}) }),
        (t = this._mergeConfigObj(t)),
        (t = this._configAfterMerge(t)),
        this._typeCheckConfig(t),
        t
      );
    }
    _configAfterMerge(t) {
      return (
        (t.container = !1 === t.container ? document.body : a(t.container)),
        "number" == typeof t.delay &&
          (t.delay = { show: t.delay, hide: t.delay }),
        "number" == typeof t.title && (t.title = t.title.toString()),
        "number" == typeof t.content && (t.content = t.content.toString()),
        t
      );
    }
    _getDelegateConfig() {
      let t = {};
      for (let [e, i] of Object.entries(this._config))
        this.constructor.Default[e] !== i && (t[e] = i);
      return (t.selector = !1), (t.trigger = "manual"), t;
    }
    _disposePopper() {
      this._popper && (this._popper.destroy(), (this._popper = null)),
        this.tip && (this.tip.remove(), (this.tip = null));
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = ey.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  b(ey);
  let ew = {
      ...ey.Default,
      content: "",
      offset: [0, 8],
      placement: "right",
      template:
        '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
      trigger: "click",
    },
    eA = { ...ey.DefaultType, content: "(null|string|element|function)" };
  class eC extends ey {
    static get Default() {
      return ew;
    }
    static get DefaultType() {
      return eA;
    }
    static get NAME() {
      return "popover";
    }
    _isWithContent() {
      return this._getTitle() || this._getContent();
    }
    _getContentForTemplate() {
      return {
        ".popover-header": this._getTitle(),
        ".popover-body": this._getContent(),
      };
    }
    _getContent() {
      return this._resolvePossibleFunction(this._config.content);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = eC.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  b(eC);
  let eE = "click.bs.scrollspy",
    eT = "active",
    ek = "[href]",
    eL = {
      offset: null,
      rootMargin: "0px 0px -25%",
      smoothScroll: !1,
      target: null,
      threshold: [0.1, 0.5, 1],
    },
    e$ = {
      offset: "(number|null)",
      rootMargin: "string",
      smoothScroll: "boolean",
      target: "element",
      threshold: "array",
    };
  class eS extends W {
    constructor(t, e) {
      super(t, e),
        (this._targetLinks = new Map()),
        (this._observableSections = new Map()),
        (this._rootElement =
          "visible" === getComputedStyle(this._element).overflowY
            ? null
            : this._element),
        (this._activeTarget = null),
        (this._observer = null),
        (this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }),
        this.refresh();
    }
    static get Default() {
      return eL;
    }
    static get DefaultType() {
      return e$;
    }
    static get NAME() {
      return "scrollspy";
    }
    refresh() {
      for (let t of (this._initializeTargetsAndObservables(),
      this._maybeEnableSmoothScroll(),
      this._observer
        ? this._observer.disconnect()
        : (this._observer = this._getNewObserver()),
      this._observableSections.values()))
        this._observer.observe(t);
    }
    dispose() {
      this._observer.disconnect(), super.dispose();
    }
    _configAfterMerge(t) {
      return (
        (t.target = a(t.target) || document.body),
        (t.rootMargin = t.offset ? `${t.offset}px 0px -30%` : t.rootMargin),
        "string" == typeof t.threshold &&
          (t.threshold = t.threshold
            .split(",")
            .map((t) => Number.parseFloat(t))),
        t
      );
    }
    _maybeEnableSmoothScroll() {
      this._config.smoothScroll &&
        (M.off(this._config.target, eE),
        M.on(this._config.target, eE, ek, (t) => {
          let e = this._observableSections.get(t.target.hash);
          if (e) {
            t.preventDefault();
            let i = this._rootElement || window,
              s = e.offsetTop - this._element.offsetTop;
            if (i.scrollTo)
              return void i.scrollTo({ top: s, behavior: "smooth" });
            i.scrollTop = s;
          }
        }));
    }
    _getNewObserver() {
      let t = {
        root: this._rootElement,
        threshold: this._config.threshold,
        rootMargin: this._config.rootMargin,
      };
      return new IntersectionObserver((t) => this._observerCallback(t), t);
    }
    _observerCallback(t) {
      let e = (t) => this._targetLinks.get(`#${t.target.id}`),
        i = (t) => {
          (this._previousScrollData.visibleEntryTop = t.target.offsetTop),
            this._process(e(t));
        },
        s = (this._rootElement || document.documentElement).scrollTop,
        n = s >= this._previousScrollData.parentScrollTop;
      for (let r of ((this._previousScrollData.parentScrollTop = s), t)) {
        if (!r.isIntersecting) {
          (this._activeTarget = null), this._clearActiveClass(e(r));
          continue;
        }
        let o = r.target.offsetTop >= this._previousScrollData.visibleEntryTop;
        if (n && o) {
          if ((i(r), !s)) return;
        } else n || o || i(r);
      }
    }
    _initializeTargetsAndObservables() {
      (this._targetLinks = new Map()), (this._observableSections = new Map());
      let t = K.find(ek, this._config.target);
      for (let e of t) {
        if (!e.hash || c(e)) continue;
        let i = K.findOne(decodeURI(e.hash), this._element);
        h(i) &&
          (this._targetLinks.set(decodeURI(e.hash), e),
          this._observableSections.set(e.hash, i));
      }
    }
    _process(t) {
      this._activeTarget !== t &&
        (this._clearActiveClass(this._config.target),
        (this._activeTarget = t),
        t.classList.add(eT),
        this._activateParents(t),
        M.trigger(this._element, "activate.bs.scrollspy", {
          relatedTarget: t,
        }));
    }
    _activateParents(t) {
      if (t.classList.contains("dropdown-item"))
        K.findOne(".dropdown-toggle", t.closest(".dropdown")).classList.add(eT);
      else
        for (let e of K.parents(t, ".nav, .list-group"))
          for (let i of K.prev(
            e,
            ".nav-link, .nav-item > .nav-link, .list-group-item"
          ))
            i.classList.add(eT);
    }
    _clearActiveClass(t) {
      t.classList.remove(eT);
      let e = K.find("[href].active", t);
      for (let i of e) i.classList.remove(eT);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = eS.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  M.on(window, "load.bs.scrollspy.data-api", () => {
    for (let t of K.find('[data-bs-spy="scroll"]')) eS.getOrCreateInstance(t);
  }),
    b(eS);
  let eI = "ArrowRight",
    eD = "ArrowDown",
    eO = "active",
    eN = "fade",
    eP = "show",
    ex =
      '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    e_ = `.nav-link:not(.dropdown-toggle), .list-group-item:not(.dropdown-toggle), [role="tab"]:not(.dropdown-toggle), ${ex}`;
  class eM extends W {
    constructor(t) {
      super(t),
        (this._parent = this._element.closest(
          '.list-group, .nav, [role="tablist"]'
        )),
        this._parent &&
          (this._setInitialAttributes(this._parent, this._getChildren()),
          M.on(this._element, "keydown.bs.tab", (t) => this._keydown(t)));
    }
    static get NAME() {
      return "tab";
    }
    show() {
      let t = this._element;
      if (this._elemIsActive(t)) return;
      let e = this._getActiveElem(),
        i = e ? M.trigger(e, "hide.bs.tab", { relatedTarget: t }) : null;
      M.trigger(t, "show.bs.tab", { relatedTarget: e }).defaultPrevented ||
        (i && i.defaultPrevented) ||
        (this._deactivate(e, t), this._activate(t, e));
    }
    _activate(t, e) {
      t &&
        (t.classList.add(eO),
        this._activate(K.getElementFromSelector(t)),
        this._queueCallback(
          () => {
            "tab" === t.getAttribute("role")
              ? (t.removeAttribute("tabindex"),
                t.setAttribute("aria-selected", !0),
                this._toggleDropDown(t, !0),
                M.trigger(t, "shown.bs.tab", { relatedTarget: e }))
              : t.classList.add(eP);
          },
          t,
          t.classList.contains(eN)
        ));
    }
    _deactivate(t, e) {
      t &&
        (t.classList.remove(eO),
        t.blur(),
        this._deactivate(K.getElementFromSelector(t)),
        this._queueCallback(
          () => {
            "tab" === t.getAttribute("role")
              ? (t.setAttribute("aria-selected", !1),
                t.setAttribute("tabindex", "-1"),
                this._toggleDropDown(t, !1),
                M.trigger(t, "hidden.bs.tab", { relatedTarget: e }))
              : t.classList.remove(eP);
          },
          t,
          t.classList.contains(eN)
        ));
    }
    _keydown(t) {
      if (!["ArrowLeft", eI, "ArrowUp", eD].includes(t.key)) return;
      t.stopPropagation(), t.preventDefault();
      let e = [eI, eD].includes(t.key),
        i = w(
          this._getChildren().filter((t) => !c(t)),
          t.target,
          e,
          !0
        );
      i && (i.focus({ preventScroll: !0 }), eM.getOrCreateInstance(i).show());
    }
    _getChildren() {
      return K.find(e_, this._parent);
    }
    _getActiveElem() {
      return this._getChildren().find((t) => this._elemIsActive(t)) || null;
    }
    _setInitialAttributes(t, e) {
      for (let i of (this._setAttributeIfNotExists(t, "role", "tablist"), e))
        this._setInitialAttributesOnChild(i);
    }
    _setInitialAttributesOnChild(t) {
      t = this._getInnerElement(t);
      let e = this._elemIsActive(t),
        i = this._getOuterElement(t);
      t.setAttribute("aria-selected", e),
        i !== t && this._setAttributeIfNotExists(i, "role", "presentation"),
        e || t.setAttribute("tabindex", "-1"),
        this._setAttributeIfNotExists(t, "role", "tab"),
        this._setInitialAttributesOnTargetPanel(t);
    }
    _setInitialAttributesOnTargetPanel(t) {
      let e = K.getElementFromSelector(t);
      e &&
        (this._setAttributeIfNotExists(e, "role", "tabpanel"),
        t.id && this._setAttributeIfNotExists(e, "aria-labelledby", `${t.id}`));
    }
    _toggleDropDown(t, e) {
      let i = this._getOuterElement(t);
      if (!i.classList.contains("dropdown")) return;
      let s = (t, s) => {
        let n = K.findOne(t, i);
        n && n.classList.toggle(s, e);
      };
      s(".dropdown-toggle", eO),
        s(".dropdown-menu", eP),
        i.setAttribute("aria-expanded", e);
    }
    _setAttributeIfNotExists(t, e, i) {
      t.hasAttribute(e) || t.setAttribute(e, i);
    }
    _elemIsActive(t) {
      return t.classList.contains(eO);
    }
    _getInnerElement(t) {
      return t.matches(e_) ? t : K.findOne(e_, t);
    }
    _getOuterElement(t) {
      return t.closest(".nav-item, .list-group-item") || t;
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = eM.getOrCreateInstance(this);
        if ("string" == typeof t) {
          if (void 0 === e[t] || t.startsWith("_") || "constructor" === t)
            throw TypeError(`No method named "${t}"`);
          e[t]();
        }
      });
    }
  }
  M.on(document, "click.bs.tab", ex, function (t) {
    ["A", "AREA"].includes(this.tagName) && t.preventDefault(),
      c(this) || eM.getOrCreateInstance(this).show();
  }),
    M.on(window, "load.bs.tab", () => {
      for (let t of K.find(
        '.active[data-bs-toggle="tab"], .active[data-bs-toggle="pill"], .active[data-bs-toggle="list"]'
      ))
        eM.getOrCreateInstance(t);
    }),
    b(eM);
  let eF = "hide",
    ej = "show",
    e9 = "showing",
    ez = { animation: "boolean", autohide: "boolean", delay: "number" },
    eH = { animation: !0, autohide: !0, delay: 5e3 };
  class eq extends W {
    constructor(t, e) {
      super(t, e),
        (this._timeout = null),
        (this._hasMouseInteraction = !1),
        (this._hasKeyboardInteraction = !1),
        this._setListeners();
    }
    static get Default() {
      return eH;
    }
    static get DefaultType() {
      return ez;
    }
    static get NAME() {
      return "toast";
    }
    show() {
      M.trigger(this._element, "show.bs.toast").defaultPrevented ||
        (this._clearTimeout(),
        this._config.animation && this._element.classList.add("fade"),
        this._element.classList.remove(eF),
        g(this._element),
        this._element.classList.add(ej, e9),
        this._queueCallback(
          () => {
            this._element.classList.remove(e9),
              M.trigger(this._element, "shown.bs.toast"),
              this._maybeScheduleHide();
          },
          this._element,
          this._config.animation
        ));
    }
    hide() {
      this.isShown() &&
        (M.trigger(this._element, "hide.bs.toast").defaultPrevented ||
          (this._element.classList.add(e9),
          this._queueCallback(
            () => {
              this._element.classList.add(eF),
                this._element.classList.remove(e9, ej),
                M.trigger(this._element, "hidden.bs.toast");
            },
            this._element,
            this._config.animation
          )));
    }
    dispose() {
      this._clearTimeout(),
        this.isShown() && this._element.classList.remove(ej),
        super.dispose();
    }
    isShown() {
      return this._element.classList.contains(ej);
    }
    _maybeScheduleHide() {
      this._config.autohide &&
        (this._hasMouseInteraction ||
          this._hasKeyboardInteraction ||
          (this._timeout = setTimeout(() => {
            this.hide();
          }, this._config.delay)));
    }
    _onInteraction(t, e) {
      switch (t.type) {
        case "mouseover":
        case "mouseout":
          this._hasMouseInteraction = e;
          break;
        case "focusin":
        case "focusout":
          this._hasKeyboardInteraction = e;
      }
      if (e) return void this._clearTimeout();
      let i = t.relatedTarget;
      this._element === i ||
        this._element.contains(i) ||
        this._maybeScheduleHide();
    }
    _setListeners() {
      M.on(this._element, "mouseover.bs.toast", (t) =>
        this._onInteraction(t, !0)
      ),
        M.on(this._element, "mouseout.bs.toast", (t) =>
          this._onInteraction(t, !1)
        ),
        M.on(this._element, "focusin.bs.toast", (t) =>
          this._onInteraction(t, !0)
        ),
        M.on(this._element, "focusout.bs.toast", (t) =>
          this._onInteraction(t, !1)
        );
    }
    _clearTimeout() {
      clearTimeout(this._timeout), (this._timeout = null);
    }
    static jQueryInterface(t) {
      return this.each(function () {
        let e = eq.getOrCreateInstance(this, t);
        if ("string" == typeof t) {
          if (void 0 === e[t]) throw TypeError(`No method named "${t}"`);
          e[t](this);
        }
      });
    }
  }
  return (
    V(eq),
    b(eq),
    {
      Alert: R,
      Button: X,
      Carousel: ta,
      Collapse: tf,
      Dropdown: tO,
      Modal: t4,
      Offcanvas: ee,
      Popover: eC,
      ScrollSpy: eS,
      Tab: eM,
      Toast: eq,
      Tooltip: ey,
    }
  );
});
